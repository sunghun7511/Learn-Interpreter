# About Interpreter

## 컴파일러와 인터프리터

### 기계어와 어셈블러

* 컴퓨터는 메모리에 로드된 `명령`을 꺼내 비트열을 해석하고 미리 준비된 일을 한다. 이 `명령`을 가리켜 기계에 준비된 언어라는 점에서 **기계어**라고 부른다.

* 기계어는 단순한 메모리상의 정보이므로 `8B EC` 처럼 표현할 수밖에 없어(16진수 표현일 때), 그 의미를 바로 파악할 수가 없다. 그래서 기계어 하나하나에 이름을 붙이고 프로그램을 이해하기 쉽게 기술하는 방법이 고안되었다. 이 언어가 **어셈블리어**이다.

* 어셈블리어 프로그램은 에디터 등으로 다음과 같이 기술된 텍스트 파일이다.

```assembly
mov  ax, b
add  ax, 10
mov  a , ax
```

* 하지만 컴퓨터는 기계어밖에 이해할 수 없다. 그래서 `어셈블러` 라는 프로그램을 사용하여 다음과 같이 변환한다.

> 어셈블리어 언어로 기술된 텍스트 파일 -> 기계어로 구성된 바이너리 파일

* 생성된 기계어 파일은 링커라는 프로그램으로 필요한 라이브러리와 일체화된다. 다음으로 로더라는 프로그램으로 컴퓨터 내에 읽어들여야 비로소 실행된다.

* 어셈블리어를 사용하면 명령들이 모두 명시적이지만, 지나치게 상세해지므로 좀 더 자연스럽게 표기할 수 있는 프로그래밍 언어가 개발되었고, 이들을 `고급언어` 라고 부른다.

### 컴파일러

고급언어로 쓴 소스 프로그램은 컴파일러를 사용해 목적 프로그램으로 변환한다.

리눅스 환경에서 `gcc` 를 사용하여 `test.c` 파일을 컴파일 할 때,

> gcc -o test test.c

와 같이 컴파일을 한다. 하지만 이 속에는 다음과 같은 과정이 숨겨져 있다.

1. 전처리기 -> `#define`, `#include` 등의 전처리 명령을 처리한다.

1. 컴파일러 -> C 언어 소스코드를 어셈블리 소스코드로 변환한다.

1. 어셈블러 -> 어셈블리 소스코드를 기계어로 번역한다.

1. 링커 -> 여러 파일들을 묶어 하나의 프로그램을 완성한다.

### 인터프리터

* 컴파일러는 내용을 변환한 목적 프로그램 파일을 만들어두고 이를 실행함으로써 실제로 프로그램을 실행한다. 이에 반해 소스 프로그램을 지정해서 직접 실행할 수 있는 것이 **인터프리터**이다.

* 컴파일 이후 실행파일을 만드는 과정을 건너뛰고, 바로 실행하는 것이다.

* 인터프리터에도 두 가지 유형이 있다.
  * 첫 번째 유형은 소스 프로그램의 텍스트 내용을 그대로 유지한다. 이 유형의 인터프리터는 소스 프로그램을 읽어들이면 메모리에 소스 코드를 그대로 유지한다. 그리고 한 문씩 해석하면서 그때마다 실행한다.
  * 두 번째 유형은 컴파일러와 통역계 루틴을 조합한 인터프리터다. 이때 컴파일러 루틴은 통상적인 처리를 해서 목적 코드를 생성한다. 컴파일 처리 자체는 순수한 컴파일러와 똑같다. 단, 처리한 결과는 디스크가 아니라 메모리에 생성된다.
  * 이 레포지토리에서는 첫 번째 유형의 인터프리터를 개발하고, 설명한다.

* 인터프리터도 기본적으로 컴파일러 이론을 기반으로 한다.

* 인터프리터나 컴파일러는 프로그램의 특성상 개발 기간이 길어지고, 프로그램의 크기가 크기 때문에 최대한 코드를 이해하기 쉽게 개발한다.

## 인터프리터의 구성

### 처리계 구성

일반적인 컴파일러 구성을 대략적으로 나타내면 다음과 같다. 간단한 컴파일러는 구문 분석에서 구문 트리 작성 단계가 없고 중간 코드 생성도 하지 않아 최적화도 최소한의 기능만 가진다.

> **소스 프로그램** -> 어휘 분석 -> 구문 분석 -> 중간 코드 생성 -> 최적화 -> 코드 생성 -> **목적 프로그램**

컴파일러와 비교하면 인터프리터의 구성은 매우 간결하다.목적 코드를 생성하지 않으므로 최적화도 거의 이루어지지 않는다. 또한, 실행하기 전에 정적인 구문 검사를 할 때도 있다.

> **소스 프로그램** -> 어휘 분석 -> 내부 코드 생성 -> 구문 분석과 실행

### 어휘 분석

읽어들인 프로그램 텍스트는 우선 `토큰`이라고 불리는 단위로 구분되어 추출된다.

### 내부 코드 생성

어휘 분석에서 추출한 토큰은 미리 정한 1바이트 기호, 혹은 `1바이트 기호 + 수치`로 표현된 내부 코드로 변환된다.

### 구문 분석과 실행

`구문 분석`에서는 분석한 토큰열이 구문과 일치하는지 확인한다. 토큰이 변수 선언이나 함수 정의일 때는 필요한 정보를 심볼 테이블에 등록한다.

분석 결과에 따라 사용할 수 없는 형을 검사하거나 필요한 경우 형변환 처리를 넣는다.

값으로 되어있는 상수 계산이나 간단한 최적화를 이 부분에서 처리한다.

구문 분석 이후 구문트리로 나타낸 다음, 순차적으로 실행한다.